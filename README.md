# Distortion

## Оглавление

1. О проекте
2. Архитектура проекта и необходимые библиотеки
3. Работа с .wav-файлами
4. Фильтры
5. Эквалайзер
6. Дисторшн
7. Тюнер

## О проекте

Хотя изначально этот проект был назван "Distortion", его задачи с течением времени вышли из рамок написания
лишь симуляции жёсткого гитарного перегруза. Если говорит кратко, то в рамках данного проекта была предпринята
попытка создания мини-VST для электрогитары, работающего с записями гитары в формате .wav. Он состоит из двух
наиболее важных частей для электрогитары: эквалайзера и дисторшн.

## Архитектура проекта и необходимые библиотеки

### Описание файлов

Если говорить о структуре проекта, то она выглядит так:
* **int_channel.py** -- _class_ WavFile (класс .wav-файла)
* **int3.py** -- функция sign_int3() (необходима для работы с 3-байтовыми сэмплами)
* **distortion.py** -- функция distortion() (сам дисторшн)
* **filters.py** -- _class_ Filter (класс фильтров эквалайзера)
* **equalizer.py** -- функция equalize() (сам эквалайзер)
* **main.py** -- основной исполнительный файл
* **tuner_test.py** -- практически независимый от остальной программы файл, в нем есть примитивный тюнер для настройки гитары

### Необходимые библиотеки

Все библиотеки либо встроенные, либо свободно импортируются с помощью pip.
* numpy
* scipy
* wavio
* matplotlib
* wave (встроенная)
* copy (встроенная)
* math (встроенная)

Для работы тюнера нужен модуль pyaudio, а вот он как раз с помощью pip не особо импортируется.
Можете почитать об этой проблеме здесь: https://ru.stackoverflow.com/questions/927657/pyaudio-не-устанавливается

## Работа с .wav-файлами

Для работы с WAVE-файлами создан класс WavFile. Он при инициализации получает название ассоциированного с ним
.wav-файла в памяти компьютера, а вдальнейшем позволяет работать с ним в удобном режиме чтения. Функционал этого класcа:
1. **Основная информация о дорожке**:
	* частота дискретизации
	* число каналов
	* размер сэмпла
	* общее число фреймов
	* длительность в секундах
2. Получение одного из каналов в виде массива из знаковых int-ов (метод channel)
3. Функции db_format и time_format для рисования графика .wav-дорожки

Также в файле draw_wave реализована одноимённая функция, которая может отрисовывать график амплитуды от времени 
для данного WAVE-файла.

## Фильтры

Для фильтрации частот был создан класс Filter. 
На вход он получает три переменные:


## Эквалайзер

_to be written..._

## Дисторшн

~~Давай уже аццкий рок!~~

### Немного теории

После описания эквализации можно перейти к нелинейным искажениям. Изначально эффекты, известные как "перегруз" --
overdrive, distortion, fuzz -- получали с помощью перегрузки схемы гитарного усилителя, в результате чего входящие
в цепочку лампы, а позже и транзисторы создавали нелинейные искажения, ограничивая или вовсе обрезая верхушки
"горбов" у синусоид чистого сигнала.

![alt text](https://github.com/MaximPovolotskii/Distortion/blob/main/Sine400Hz.png )

![alt text](https://github.com/MaximPovolotskii/Distortion/blob/main/Clipped_sine.png)

Если разложить такой искажённый в спектр, то получится изначальный спектр, значительно обогащённый гармониками -- частотами,
которые кратны доминирующим частотам в изначально спектре. Вот что получится, если провести чистую синусоиду через такое
обрезание:

![alt text](https://github.com/MaximPovolotskii/Distortion/blob/main/Clipping_spectrum.png)

В современном мире аналоговое искажение чаще транзисторное -- жёстко ограничивающее сигнал по амплитуде, а если разложить 
такую псевдомеандровую функцию в ряд Фурье, то получится ряд только из нечётных гармоник с амплитудами, обратно 
пропорциональными частотам, что видно на картинках выше. Они придают агрессивное, жужжащее звучание.

Но это не все тонкости: если обрезать сигнал слишком резко, то получится слишком много неприятных призвуков, поэтому ограничение
не должно быть "угловатым". Также перед таким искажением и после него нужно проводить фильтрацию сверхнизких и сверхвысоких
частот, чтобы звук не "захлёбывался", не "бубнил" и не был очень "песочным", с призвуком помех. В аналоговых схемах такая
фильтрация проводится перед и после ограничения по амплитуде.

И последнее: АЧХ транзистора также влияет и на средние частоты -- там тоже есть области "глушения" и области "усиления" в спектре,
поэтому при симуляции нелинейных искажений нужно проводить и фильтрацию в средней части спектра.

### На практике

В нашем проекте дисторшн реализован в функции distortion. Её аргументы: 
* канал, который мы искажаем (*channel*)
* длительность канала (*duration*)
* предельная амплитуда, по которой будет происходить ограничение после растяжения (*roof*)
* величина гейна -- силы перегруза (*set_gain*)

Функция выполняет предэквализацию, растяжение с ограничением амплитуды (использование *tanh(x)*) и постэквализацию.

Возвращаемый объект -- канал, обработанный дисторшном (массив интов, аналогичный channel)

_to be written..._
